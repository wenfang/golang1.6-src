// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Time-related runtime and pieces of package time.

package runtime

import "unsafe"

// Package time knows the layout of this structure.
// If this struct changes, adjust ../time/sleep.go:/runtimeTimer.
// For GOOS=nacl, package syscall knows the layout of this structure.
// If this struct changes, adjust ../syscall/net_nacl.go:/runtimeTimer.
type timer struct { // 定时器结构，与time/sleep.go中的结构相同
	i int // heap index 堆索引

	// Timer wakes up at when, and then at when+period, ... (period > 0 only)
	// each time calling f(arg, now) in the timer goroutine, so f must be
	// a well-behaved function and not block.
	when   int64                      // 启动开始时间
	period int64                      // 周期性执行时间
	f      func(interface{}, uintptr) // 到期后执行的函数
	arg    interface{}                // 到期后执行函数的参数
	seq    uintptr
}

var timers struct { // 全局唯一的timers变量
	lock         mutex // timers的锁
	gp           *g    // 定时器goroutine
	created      bool  // 定时器goroutine是否已被创建
	sleeping     bool  // 定时器goroutine是否处于睡眠状态
	rescheduling bool  // 是否重新调度，如果重新调度表明没有定时器了，可放弃当前的m
	waitnote     note
	t            []*timer // 定时器结构的列表
}

// nacl fake time support - time in nanoseconds since 1970
var faketime int64 // nacl的fack时间支持

// Package time APIs.
// Godoc uses the comments in package time, not these.

// time.now is implemented in assembly.

// timeSleep puts the current goroutine to sleep for at least ns nanoseconds.
//go:linkname timeSleep time.Sleep
func timeSleep(ns int64) { // 睡眠ns时间
	if ns <= 0 { // n不能小于等于0
		return
	}

	t := new(timer)          // 创建新的timer结构
	t.when = nanotime() + ns // 获取唤醒时间
	t.f = goroutineReady     // 唤醒后执行goroutineReady
	t.arg = getg()
	lock(&timers.lock)
	addtimerLocked(t)
	goparkunlock(&timers.lock, "sleep", traceEvGoSleep, 2)
}

// startTimer adds t to the timer heap.
//go:linkname startTimer time.startTimer
func startTimer(t *timer) { // 增加一个定时器
	if raceenabled {
		racerelease(unsafe.Pointer(t))
	}
	addtimer(t)
}

// stopTimer removes t from the timer heap if it is there.
// It returns true if t was removed, false if t wasn't even there.
//go:linkname stopTimer time.stopTimer
func stopTimer(t *timer) bool { // 删除定时器
	return deltimer(t)
}

// Go runtime.

// Ready the goroutine arg.
func goroutineReady(arg interface{}, seq uintptr) {
	goready(arg.(*g), 0)
}

func addtimer(t *timer) { // 添加定时器
	lock(&timers.lock)
	addtimerLocked(t)
	unlock(&timers.lock)
}

// Add a timer to the heap and start or kick the timer proc.
// If the new timer is earlier than any of the others.
// Timers are locked.
func addtimerLocked(t *timer) { // 在加锁之后添加定时结构timer
	// when must never be negative; otherwise timerproc will overflow
	// during its delta calculation and never expire other runtime·timers.
	if t.when < 0 { // when不能小于0
		t.when = 1<<63 - 1 // 小于0则设置很大的值
	}
	t.i = len(timers.t)            // 获取定时列表长度
	timers.t = append(timers.t, t) // 将定时结构添加到定时列表
	siftupTimer(t.i)               // 维护定时列表的堆算法
	if t.i == 0 {                  // 如果加入的变成了第一个
		// siftup moved to top: new earliest deadline.
		if timers.sleeping { // 如果定时器goroutine处于睡眠状态
			timers.sleeping = false
			notewakeup(&timers.waitnote) // 唤醒定时器goroutine
		}
		if timers.rescheduling { // 如果可以重新调度
			timers.rescheduling = false // 不能重新调度了
			goready(timers.gp, 0)       // ready定时器goroutine
		}
	}
	if !timers.created { // 如果定时器goroutine还未创建
		timers.created = true // 设置定时器goroutine创建
		go timerproc()        // 启动定时器处理goroutine
	}
}

// Delete timer t from the heap.
// Do not need to update the timerproc: if it wakes up early, no big deal.
func deltimer(t *timer) bool { // 删除定时器
	// Dereference t so that any panic happens before the lock is held.
	// Discard result, because t might be moving in the heap.
	_ = t.i // 可能timer已经移除，在这里发出panic

	lock(&timers.lock) // 定时器锁定
	// t may not be registered anymore and may have
	// a bogus i (typically 0, if generated by Go).
	// Verify it before proceeding.
	i := t.i // 取出来timer所在的位置
	last := len(timers.t) - 1
	if i < 0 || i > last || timers.t[i] != t { // 如果timer已经不在堆列表中了，返回false
		unlock(&timers.lock)
		return false
	}
	if i != last {
		timers.t[i] = timers.t[last]
		timers.t[i].i = i
	}
	timers.t[last] = nil
	timers.t = timers.t[:last]
	if i != last {
		siftupTimer(i)
		siftdownTimer(i)
	}
	unlock(&timers.lock)
	return true // 删除timer，返回true
}

// Timerproc runs the time-driven events.
// It sleeps until the next event in the timers heap.
// If addtimer inserts a new earlier event, addtimer1 wakes timerproc early.
func timerproc() { // 用于处理定时器的goroutine
	timers.gp = getg() // 获取当前的goroutine
	for {
		lock(&timers.lock)      // timers加锁
		timers.sleeping = false // 当前的timers已经处于运行状态了
		now := nanotime()       // 获取当前的时间
		delta := int64(-1)
		for {
			if len(timers.t) == 0 { // 如果timer列表为空，跳出循环
				delta = -1
				break
			}
			t := timers.t[0] // 取出来第一个定时器
			delta = t.when - now
			if delta > 0 { // 如果还没到时间，跳出循环
				break
			}
			if t.period > 0 { // 到时间了，需要周期执行，再创建一个
				// leave in heap but adjust next time to fire
				t.when += t.period * (1 + -delta/t.period)
				siftdownTimer(0)
			} else { // 到时间了不需要周期执行，删除
				// remove from heap
				last := len(timers.t) - 1
				if last > 0 {
					timers.t[0] = timers.t[last]
					timers.t[0].i = 0
				}
				timers.t[last] = nil
				timers.t = timers.t[:last]
				if last > 0 {
					siftdownTimer(0)
				}
				t.i = -1 // mark as removed
			}
			f := t.f
			arg := t.arg
			seq := t.seq
			unlock(&timers.lock) // 先释放定时器列表锁
			if raceenabled {
				raceacquire(unsafe.Pointer(t))
			}
			f(arg, seq) // 执行定时器函数
			lock(&timers.lock)
		}
		if delta < 0 || faketime > 0 {
			// No timers left - put goroutine to sleep. 没有timer了，将goroutine置为sleep状态
			timers.rescheduling = true                                              // 设置timers重新调度
			goparkunlock(&timers.lock, "timer goroutine (idle)", traceEvGoBlock, 1) // 等待在这里
			continue                                                                // 切换回来了，继续循环
		}
		// At least one timer pending.  Sleep until then. 至少有一个待执行的timer，睡眠直到可以执行
		timers.sleeping = true      // 设置timer处于睡眠状态
		noteclear(&timers.waitnote) // 先清空waitnote
		unlock(&timers.lock)
		notetsleepg(&timers.waitnote, delta) // 睡眠等待delta时间
	}
}

func timejump() *g {
	if faketime == 0 {
		return nil
	}

	lock(&timers.lock)
	if !timers.created || len(timers.t) == 0 {
		unlock(&timers.lock)
		return nil
	}

	var gp *g
	if faketime < timers.t[0].when {
		faketime = timers.t[0].when
		if timers.rescheduling {
			timers.rescheduling = false
			gp = timers.gp
		}
	}
	unlock(&timers.lock)
	return gp
}

// Heap maintenance algorithms.

func siftupTimer(i int) { // 维护定时列表的堆算法，增加一项i
	t := timers.t
	when := t[i].when
	tmp := t[i]
	for i > 0 {
		p := (i - 1) / 4 // parent
		if when >= t[p].when {
			break
		}
		t[i] = t[p]
		t[i].i = i
		t[p] = tmp
		t[p].i = p
		i = p
	}
}

func siftdownTimer(i int) { // 维护定时列表的堆算法，删除一项i
	t := timers.t
	n := len(t)
	when := t[i].when
	tmp := t[i]
	for {
		c := i*4 + 1 // left child
		c3 := c + 2  // mid child
		if c >= n {
			break
		}
		w := t[c].when
		if c+1 < n && t[c+1].when < w {
			w = t[c+1].when
			c++
		}
		if c3 < n {
			w3 := t[c3].when
			if c3+1 < n && t[c3+1].when < w3 {
				w3 = t[c3+1].when
				c3++
			}
			if w3 < w {
				w = w3
				c = c3
			}
		}
		if w >= when {
			break
		}
		t[i] = t[c]
		t[i].i = i
		t[c] = tmp
		t[c].i = c
		i = c
	}
}

// Entry points for net, time to call nanotime.

//go:linkname net_runtimeNano net.runtimeNano
func net_runtimeNano() int64 {
	return nanotime()
}

//go:linkname time_runtimeNano time.runtimeNano
func time_runtimeNano() int64 {
	return nanotime()
}
